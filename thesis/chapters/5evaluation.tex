\chapter{Evaluation}

\section{Performance on SPEC 2006}

All measurements were made on Intel ?? with 8 GB RAM, running Ubuntu 14.04 LTS, with Linux kernel version ??.

Performance overhead of Dangless was measured on the standard SPEC2006 benchmarking suite using the VUSec group's \texttt{instrumentation-infra} framework~\cite{vusec-infra}. Dangless was built and configured in the following manner:

\begin{lstlisting}[breaklines, language=bash, style=]
./setup.py build \
	--dangless-config ALLOW_SYSMALLOC_FALLBACK=Off \
	--dangless-config COLLECT_STATISTICS=Off \
	--dangless-config ENABLE_PERF_EVENTS=Off \
	--dangless-config REPORT_RUSAGE=Off \
	--dangless-config SYSCALLMETA_HAS_INFO=Off \
	--targets spec2006 \
	--instances dangless-malloc
\end{lstlisting}

This corresponds to building Dangless manually using:

\begin{lstlisting}[breaklines, language=bash, style=]
cmake \
	-D CMAKE_BUILD_TYPE=RelWithDebInfo \
	-D ALLOW_SYSMALLOC_FALLBACK=Off \
	-D COLLECT_STATISTICS=Off \
	-D ENABLE_PERF_EVENTS=Off \
	-D REPORT_RUSAGE=Off \
	-D SYSCALLMETA_HAS_INFO=Off \
	..

cmake --build .
\end{lstlisting}

\begin{lstlisting}[breaklines, language=bash, style=]
./setup.py run spec2006 dangless-malloc --test --benchmarks all_c all_cpp
\end{lstlisting}

Dangless successfully runs on all C and C++ benchmarks with the exception of \path{400.perlbench} with test workload due to its use of the unsupported \lstinline!clone()! system call. \todo{Perlbench also doesn't run in reference, why?}

% Performance overhead: Dune vs Dangless vs Oscar
\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            ybar,
            scale only axis, % width and height only for the contents, not labels
            width=\textwidth,
            %height=0.65\paperheight,
            xtick=data,
            xticklabels from table={data/perf_vs_oscar.dat}{benchmark},
            xticklabel style={rotate=90},
            yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},
            ymin=0,
            ymax=0.5,
            point meta={y*100},
            %nodes near coords={\pgfmathprintnumber\pgfplotspointmeta\%},
            %nodes near coords align={horizontal},
            bar width=4pt,
            ymajorgrids=true,
            legend style={
                at={(0.15,0.975)},
                anchor=north,
                %legend columns=-1
            },
        ]
            \addplot table [
                x expr=\coordindex,
                y expr=\thisrow{dune} - 1,
                %skip coords between index={15}{100}
            ] {data/perf_vs_oscar.dat};
            
            \addplot table [
                x expr=\coordindex,
                y expr=\thisrow{dangless} - 1,
                %skip coords between index={15}{100}
            ] {data/perf_vs_oscar.dat};
            
            \addplot table [
                x expr=\coordindex,
                y expr=\thisrow{oscar_estm} - 1,
                %skip coords between index={15}{100}
            ] {data/perf_vs_oscar.dat};
            
            \legend{Dune only, Dangless, Oscar}
        \end{axis}
    \end{tikzpicture}
    \caption{Dune vs Dangless vs Oscar: performance overhead}
\end{figure}

% Memory overhead: Dune vs Dangless vs Oscar
\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            ybar,
            scale only axis, % width and height only for the contents, not labels
            width=\textwidth,
            %height=0.65\paperheight,
            xtick=data,
            xticklabels from table={data/mem_vs_oscar.dat}{benchmark},
            xticklabel style={rotate=90},
            yticklabel={\pgfmathparse{\tick*100}\pgfmathprintnumber{\pgfmathresult}\%},
            ymin=0,
            ymax=1.5,
            point meta={y*100},
            %nodes near coords={\pgfmathprintnumber\pgfplotspointmeta\%},
            %nodes near coords align={horizontal},
            bar width=4pt,
            ymajorgrids=true,
            legend style={
                at={(0.15,0.975)},
                anchor=north,
                %legend columns=-1
            },
        ]
            \addplot table [
                x expr=\coordindex,
                y expr=\thisrow{dune} - 1,
                %skip coords between index={15}{100}
            ] {data/mem_vs_oscar.dat};
            
            \addplot table [
                x expr=\coordindex,
                y expr=\thisrow{dangless} - 1,
                %skip coords between index={15}{100}
            ] {data/mem_vs_oscar.dat};
            
            \addplot table [
                x expr=\coordindex,
                y expr=\thisrow{oscar_estm} - 1,
                %skip coords between index={15}{100}
            ] {data/mem_vs_oscar.dat};
            
            \legend{Dune only, Dangless, Oscar}
        \end{axis}
    \end{tikzpicture}
    \caption{Dune vs Dangless vs Oscar: memory overhead}
\end{figure}

\section{Summary of contributions}

Dangless Malloc demonstrates the power of process-level, hardware-assisted virtualization and its use for hardening processes against bugs and malicious users without having to pay the usual performance price associated with system calls. This makes the approach of creating and destroying shadow virtual pages, used by previous work such as Oscar~\cite{oscar2017}, noticeably cheaper, without making the design significantly more complex.

\todo{Anything else?}

\section{Limitations and improvement opportunities}

Dangless Malloc was created as a proof of concept, and its implementation could be improved in various ways.

For instance, the \lstinline!realloc()! implementation is not optimal: even if the system allocator was unable to perform an in-place reallocation, we could still potentially do so with the remapped pages, if the virtual memory region following them is available. Care should only be taken to modify the page table entry of each of the old virtual page mappings to point to the new physical addresses.

Similarly, there's no real reason why Dangless is currently unable to handle the system allocator returning a virtual memory region that is not backed by contiguous guest physical memory.

As discussed earlier, Dangless could be smarter about its virtual memory auto-dedication logic, for example by acquiring unused virtual memory regions on-demand. We could also be using hugepages for the shadow virtual memory when the allocation size is greater than 2 MB or 1 GB.

In order to make it easier to incorporate Dangless into projects, it should support installation and exporting its CMake targets.

Major improvement opportunities would be supporting multi-threaded applications, after investigating Dune's state of support for it, and supporting the \lstinline!clone()! system call.

Finally, some mechanism for reclaiming virtual memory once we can reasonably guarantee the absence of pointers to them would ensure that we never run out of virtual memory even in long-running applications such as web servers.

\section{Conclusion}

\todo{...}
