#include <unistd.h>
#include <sys/syscall.h>

#include "dangless/common/types.h"
#include "dangless/common/dprintf.h"
#include "dangless/common/util.h"
#include "dangless/syscallmeta.h"

// dangless/build/common/syscallmeta.inc is generated by vendor/linux-syscallmd/generate_c_header.py
// dangless/build/common/syscall_userptr_info.inc is generated by scripts/gen_syscall_userptr_info.py

// TODO: use bitmap instead??
/*static const i8 g_syscall_ptr_params[][SYSCALL_MAX_ARGS + 1] = {
  #define SYSCALL_USERPTR_PARAMS(NUM, NAME, ...) \
    [NUM] = { __VA_ARGS__ },

  #include "dangless/build/common/syscall_userptr_info.inc"
};

const i8 *syscall_get_userptr_params(index_t syscallno) {
  if (syscallno >= ARRAY_LENGTH(g_syscall_ptr_params)
      || g_syscall_ptr_params[syscallno][0] == 0)
    return NULL;

  return g_syscall_ptr_params[syscallno];
}*/

#if DANGLESS_CONFIG_SYSCALLMETA_HAS_INFO

  static const struct syscall_info g_syscall_infos[] = {
    #define SYSCALL_SIGNATURE(NUM, NAME, NUM_PARAMS, ...) \
      [NUM] = { \
        NUM, \
        #NAME, \
        NUM_PARAMS, \
        /*params=*/ {

    #define SYSCALL_PARAM(POS, TYPE, NAME, IS_USER_PTR) \
        { POS, #TYPE, #NAME, IS_USER_PTR },

    #define SYSCALL_END(NUM, NAME, NUM_PARAMS, ...) \
        } /* end params */, \
        /*signature=*/ #NAME " (" #__VA_ARGS__ ")" \
      },

    #include "dangless/build/common/syscallmeta.inc"
  };

  const struct syscall_info *syscall_get_info(index_t syscallno) {
    if (syscallno >= ARRAY_LENGTH(g_syscall_infos)
        || !g_syscall_infos[syscallno].name)
      return NULL;

    return &g_syscall_infos[syscallno];
  }

#endif // DANGLESS_CONFIG_SYSCALLMETA_HAS_INFO

static void syscall_log_noinfo(u64 syscallno, u64 args[]) {
  dprintf_nomalloc("syscall [%lu]: (\n", syscallno);
  for (index_t i = 0; i < SYSCALL_MAX_ARGS; i++) {
    dprintf_nomalloc("\targ%ld = %lu (0x%lx)\n", i, args[i], args[i]);
  }
  dprintf_nomalloc(")\n");
}

void syscall_log(u64 syscallno, u64 args[]) {
  #if DANGLESS_CONFIG_SYSCALLMETA_HAS_INFO
    const struct syscall_info *info = syscall_get_info(syscallno);
    if (!info) {
      dprintf_nomalloc("UNKNOWN ");
      syscall_log_noinfo(syscallno, args);
      return;
    }

    dprintf_nomalloc("syscall [%lu]: %s(\n", syscallno, info->name);
    for (index_t i = 0; i < info->num_params; i++) {
      dprintf_nomalloc("\t%s %s = %lu (0x%lx)\n", info->params[i].type, info->params[i].name, args[i], args[i]);
    }
    dprintf_nomalloc(")\n");
  #else
    syscall_log_noinfo(syscallno, args);
  #endif
}
