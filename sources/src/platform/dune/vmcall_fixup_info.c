#include "vmcall_fixup_info.h"
#include "vmcall_hooks.h"

#include "dangless/config.h"
#include "dangless/common/dprintf.h"

#include <sys/syscall.h> // for the __NR_ macros

#if DANGLESS_CONFIG_DEBUG_DUNE_VMCALL_FIXUP
  #define LOG(...) \
    if (vmcall_should_trace_current()) \
      vdprintf_nomalloc(__VA_ARGS__)
#else
  #define LOG(...) /* empty */
#endif

const char *vmcall_param_fixup_type_str(enum vmcall_param_fixup_type type) {
  switch (type) {
    #define HANDLE_VALUE(VAL) \
      case CONCAT2(VMCALL_PARAM_, VAL): \
        return #VAL;

    HANDLE_VALUE(NONE);
    HANDLE_VALUE(FLAT_PTR);
    HANDLE_VALUE(IOVEC);
    HANDLE_VALUE(PTR_PTR);
    HANDLE_VALUE(MSGHDR);
    HANDLE_VALUE(END);

    #undef HANDLE_VALUE
  }
}

// indexed by system call number
static const struct vmcall_fixup_info g_vmcall_fixup_info_table[] = {
  // generated by make/gen_vmcall_fixup_info.py
  #include "dangless/build/common/vmcall_fixup_info.inc"
};

const struct vmcall_fixup_info *vmcall_get_fixup_info(u64 syscallno) {
  // workaround: handle clone() specially, because the linux-syscallmd cannot handle the #if-s surrounding its various prototypes properly
  if (syscallno == (u64)56) {
    /*
      The raw system call interface on x86-64 and some other architectures (including sh, tile, and alpha) is:

       long clone(unsigned long flags, void *child_stack,
                  int *ptid, int *ctid,
                  unsigned long newtls);

      Source: http://man7.org/linux/man-pages/man2/clone.2.html
    */

    static const struct vmcall_fixup_info s_clone_info = {
      .params = {
        // unsigned long flags
        [0] = {
          .fixup_type = VMCALL_PARAM_NONE
        },

        // void *child_stack
        [1] = {
          .fixup_type = VMCALL_PARAM_FLAT_PTR
        },

        // int *ptid
        [2] = {
          .fixup_type = VMCALL_PARAM_FLAT_PTR
        },

        // int *ctid
        [3] = {
          .fixup_type = VMCALL_PARAM_FLAT_PTR
        },

        // unsigned long newtls
        [4] = {
          .fixup_type = VMCALL_PARAM_NONE
        },

        [5] = {
          .fixup_type = VMCALL_PARAM_END
        }
      }
    };

    return &s_clone_info;
  }

  if (syscallno >= ARRAY_LENGTH(g_vmcall_fixup_info_table)) {
    LOG("requested vmcall fixup info for syscall number %lu, which doesn't exist, returning NULL", syscallno);
    return NULL;
  }

  return &g_vmcall_fixup_info_table[syscallno];
}
